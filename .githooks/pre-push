#!/bin/sh
set -e

ZERO_SHA="0000000000000000000000000000000000000000"
REMOTE_NAME="$1"

has_manifest_changes() {
  range="$1"
  if [ -z "$range" ]; then
    return 1
  fi

  git diff --name-only "$range" -- package.json package-lock.json | grep -q .
}

should_audit=0
audit_reason=""

while read local_ref local_sha remote_ref remote_sha
do
  # Deletions have no local SHA to inspect.
  if [ "$local_sha" = "$ZERO_SHA" ]; then
    continue
  fi

  if [ "$remote_sha" = "$ZERO_SHA" ]; then
    # New remote ref. Diff from remote main merge-base when available.
    base_ref=""
    if [ -n "$REMOTE_NAME" ] && git show-ref --verify --quiet "refs/remotes/$REMOTE_NAME/main"; then
      base_ref=$(git merge-base "$local_sha" "refs/remotes/$REMOTE_NAME/main" || true)
    fi

    if [ -n "$base_ref" ]; then
      range="$base_ref..$local_sha"
    else
      # No safe base to diff against (e.g. local clone without fetched remote main).
      # Be conservative: run audit instead of risking a false "skip".
      should_audit=1
      audit_reason="no_safe_base"
      printf "%s\n" "[pre-push] Could not determine base for new remote ref; running npm audit conservatively"
      break
    fi
  else
    range="$remote_sha..$local_sha"
  fi

  if has_manifest_changes "$range"; then
    should_audit=1
    audit_reason="manifest_change"
    break
  fi
done

if [ "$should_audit" -eq 0 ]; then
  printf "%s\n" "[pre-push] No package manifest changes in push range; skipping npm audit"
  exit 0
fi

if [ "$audit_reason" = "manifest_change" ]; then
  printf "%s\n" "[pre-push] package.json/package-lock.json changed; running npm audit --audit-level=high"
else
  printf "%s\n" "[pre-push] Running npm audit --audit-level=high (conservative check)"
fi
npm audit --audit-level=high
